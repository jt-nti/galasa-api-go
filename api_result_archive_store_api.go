/*
Galasa Ecosystem API

The Galasa Ecosystem REST API allows you to interact with a Galasa Ecosystem.

API version: 0.37.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package galasaapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
	"time"
)


// ResultArchiveStoreAPIAPIService ResultArchiveStoreAPIAPI service
type ResultArchiveStoreAPIAPIService service

type ApiDeleteRasRunByIdRequest struct {
	ctx context.Context
	ApiService *ResultArchiveStoreAPIAPIService
	runid string
	clientApiVersion *string
}

func (r ApiDeleteRasRunByIdRequest) ClientApiVersion(clientApiVersion string) ApiDeleteRasRunByIdRequest {
	r.clientApiVersion = &clientApiVersion
	return r
}

func (r ApiDeleteRasRunByIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteRasRunByIdExecute(r)
}

/*
DeleteRasRunById Delete run from the RAS using a given run ID

Deletes a test run and its corresponding artifacts from the RAS given the run's ID.

Requests to this endpoint require a valid bearer token in JWT format to be provided
in the 'Authorization' header (e.g. 'Authorization: Bearer <bearer-token>').


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param runid Run Id which starts \"cdb-\". This is NOT the short run-name (e.g. C1234)
 @return ApiDeleteRasRunByIdRequest
*/
func (a *ResultArchiveStoreAPIAPIService) DeleteRasRunById(ctx context.Context, runid string) ApiDeleteRasRunByIdRequest {
	return ApiDeleteRasRunByIdRequest{
		ApiService: a,
		ctx: ctx,
		runid: runid,
	}
}

// Execute executes the request
func (a *ResultArchiveStoreAPIAPIService) DeleteRasRunByIdExecute(r ApiDeleteRasRunByIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResultArchiveStoreAPIAPIService.DeleteRasRunById")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ras/runs/{runid}"
	localVarPath = strings.Replace(localVarPath, "{"+"runid"+"}", url.PathEscape(parameterValueToString(r.runid, "runid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.clientApiVersion != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "ClientApiVersion", r.clientApiVersion, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetRasRequestorsRequest struct {
	ctx context.Context
	ApiService *ResultArchiveStoreAPIAPIService
	clientApiVersion *string
	sort *string
}

func (r ApiGetRasRequestorsRequest) ClientApiVersion(clientApiVersion string) ApiGetRasRequestorsRequest {
	r.clientApiVersion = &clientApiVersion
	return r
}

// provides sorting, requestor:asc or requestor:desc
func (r ApiGetRasRequestorsRequest) Sort(sort string) ApiGetRasRequestorsRequest {
	r.sort = &sort
	return r
}

func (r ApiGetRasRequestorsRequest) Execute() (*Requestors, *http.Response, error) {
	return r.ApiService.GetRasRequestorsExecute(r)
}

/*
GetRasRequestors Get all known requestors

Returns the list of all known requestors that have launched tests in the ecosystem.

Requests to this endpoint require a valid bearer token in JWT format to be provided
in the 'Authorization' header (e.g. 'Authorization: Bearer <bearer-token>').


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetRasRequestorsRequest
*/
func (a *ResultArchiveStoreAPIAPIService) GetRasRequestors(ctx context.Context) ApiGetRasRequestorsRequest {
	return ApiGetRasRequestorsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Requestors
func (a *ResultArchiveStoreAPIAPIService) GetRasRequestorsExecute(r ApiGetRasRequestorsRequest) (*Requestors, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Requestors
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResultArchiveStoreAPIAPIService.GetRasRequestors")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ras/requestors"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.clientApiVersion != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "ClientApiVersion", r.clientApiVersion, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRasResultNamesRequest struct {
	ctx context.Context
	ApiService *ResultArchiveStoreAPIAPIService
	clientApiVersion *string
	sort *string
}

func (r ApiGetRasResultNamesRequest) ClientApiVersion(clientApiVersion string) ApiGetRasResultNamesRequest {
	r.clientApiVersion = &clientApiVersion
	return r
}

// provides sorting, results:asc or results:desc
func (r ApiGetRasResultNamesRequest) Sort(sort string) ApiGetRasResultNamesRequest {
	r.sort = &sort
	return r
}

func (r ApiGetRasResultNamesRequest) Execute() (*ResultNames, *http.Response, error) {
	return r.ApiService.GetRasResultNamesExecute(r)
}

/*
GetRasResultNames Get all the known result names

Returns a list of the known result names that a test can be assigned (e.g. "Passed", "Failed", "EnvFail", etc.).

Requests to this endpoint require a valid bearer token in JWT format to be provided
in the 'Authorization' header (e.g. 'Authorization: Bearer <bearer-token>').


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetRasResultNamesRequest
*/
func (a *ResultArchiveStoreAPIAPIService) GetRasResultNames(ctx context.Context) ApiGetRasResultNamesRequest {
	return ApiGetRasResultNamesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ResultNames
func (a *ResultArchiveStoreAPIAPIService) GetRasResultNamesExecute(r ApiGetRasResultNamesRequest) (*ResultNames, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResultNames
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResultArchiveStoreAPIAPIService.GetRasResultNames")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ras/resultnames"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.clientApiVersion != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "ClientApiVersion", r.clientApiVersion, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRasRunArtifactByPathRequest struct {
	ctx context.Context
	ApiService *ResultArchiveStoreAPIAPIService
	runid string
	artifactPath string
	clientApiVersion *string
}

func (r ApiGetRasRunArtifactByPathRequest) ClientApiVersion(clientApiVersion string) ApiGetRasRunArtifactByPathRequest {
	r.clientApiVersion = &clientApiVersion
	return r
}

func (r ApiGetRasRunArtifactByPathRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetRasRunArtifactByPathExecute(r)
}

/*
GetRasRunArtifactByPath Download artifact for a given runid by artifactPath

Downloads a test artifact for a given test run using its run ID and the path of the artifact to download.

Requests to this endpoint require a valid bearer token in JWT format to be provided
in the 'Authorization' header (e.g. 'Authorization: Bearer <bearer-token>').


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param runid Run Id
 @param artifactPath Run Artifact path
 @return ApiGetRasRunArtifactByPathRequest
*/
func (a *ResultArchiveStoreAPIAPIService) GetRasRunArtifactByPath(ctx context.Context, runid string, artifactPath string) ApiGetRasRunArtifactByPathRequest {
	return ApiGetRasRunArtifactByPathRequest{
		ApiService: a,
		ctx: ctx,
		runid: runid,
		artifactPath: artifactPath,
	}
}

// Execute executes the request
//  @return *os.File
func (a *ResultArchiveStoreAPIAPIService) GetRasRunArtifactByPathExecute(r ApiGetRasRunArtifactByPathRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResultArchiveStoreAPIAPIService.GetRasRunArtifactByPath")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ras/runs/{runid}/files/{artifactPath}"
	localVarPath = strings.Replace(localVarPath, "{"+"runid"+"}", url.PathEscape(parameterValueToString(r.runid, "runid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"artifactPath"+"}", url.PathEscape(parameterValueToString(r.artifactPath, "artifactPath")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.clientApiVersion != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "ClientApiVersion", r.clientApiVersion, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRasRunArtifactListRequest struct {
	ctx context.Context
	ApiService *ResultArchiveStoreAPIAPIService
	runid string
	clientApiVersion *string
}

func (r ApiGetRasRunArtifactListRequest) ClientApiVersion(clientApiVersion string) ApiGetRasRunArtifactListRequest {
	r.clientApiVersion = &clientApiVersion
	return r
}

func (r ApiGetRasRunArtifactListRequest) Execute() ([]ArtifactIndexEntry, *http.Response, error) {
	return r.ApiService.GetRasRunArtifactListExecute(r)
}

/*
GetRasRunArtifactList Get the available run artifacts which can be downloaded.

Returns a list of the available artifacts for a given test run.

Requests to this endpoint require a valid bearer token in JWT format to be provided
in the 'Authorization' header (e.g. 'Authorization: Bearer <bearer-token>').


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param runid Run Id
 @return ApiGetRasRunArtifactListRequest
*/
func (a *ResultArchiveStoreAPIAPIService) GetRasRunArtifactList(ctx context.Context, runid string) ApiGetRasRunArtifactListRequest {
	return ApiGetRasRunArtifactListRequest{
		ApiService: a,
		ctx: ctx,
		runid: runid,
	}
}

// Execute executes the request
//  @return []ArtifactIndexEntry
func (a *ResultArchiveStoreAPIAPIService) GetRasRunArtifactListExecute(r ApiGetRasRunArtifactListRequest) ([]ArtifactIndexEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ArtifactIndexEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResultArchiveStoreAPIAPIService.GetRasRunArtifactList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ras/runs/{runid}/artifacts"
	localVarPath = strings.Replace(localVarPath, "{"+"runid"+"}", url.PathEscape(parameterValueToString(r.runid, "runid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.clientApiVersion != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "ClientApiVersion", r.clientApiVersion, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRasRunByIdRequest struct {
	ctx context.Context
	ApiService *ResultArchiveStoreAPIAPIService
	runid string
	clientApiVersion *string
}

func (r ApiGetRasRunByIdRequest) ClientApiVersion(clientApiVersion string) ApiGetRasRunByIdRequest {
	r.clientApiVersion = &clientApiVersion
	return r
}

func (r ApiGetRasRunByIdRequest) Execute() (*Run, *http.Response, error) {
	return r.ApiService.GetRasRunByIdExecute(r)
}

/*
GetRasRunById Get Run by ID

Returns the details of a test run given its ID.

Requests to this endpoint require a valid bearer token in JWT format to be provided
in the 'Authorization' header (e.g. 'Authorization: Bearer <bearer-token>').


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param runid Run Id which starts \"cdb-\". This is NOT the short run-name (e.g. C1234)
 @return ApiGetRasRunByIdRequest
*/
func (a *ResultArchiveStoreAPIAPIService) GetRasRunById(ctx context.Context, runid string) ApiGetRasRunByIdRequest {
	return ApiGetRasRunByIdRequest{
		ApiService: a,
		ctx: ctx,
		runid: runid,
	}
}

// Execute executes the request
//  @return Run
func (a *ResultArchiveStoreAPIAPIService) GetRasRunByIdExecute(r ApiGetRasRunByIdRequest) (*Run, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Run
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResultArchiveStoreAPIAPIService.GetRasRunById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ras/runs/{runid}"
	localVarPath = strings.Replace(localVarPath, "{"+"runid"+"}", url.PathEscape(parameterValueToString(r.runid, "runid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.clientApiVersion != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "ClientApiVersion", r.clientApiVersion, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRasRunLogRequest struct {
	ctx context.Context
	ApiService *ResultArchiveStoreAPIAPIService
	runid string
	clientApiVersion *string
}

func (r ApiGetRasRunLogRequest) ClientApiVersion(clientApiVersion string) ApiGetRasRunLogRequest {
	r.clientApiVersion = &clientApiVersion
	return r
}

func (r ApiGetRasRunLogRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.GetRasRunLogExecute(r)
}

/*
GetRasRunLog Get Run Log

Returns the logs for a given test run in plaintext.

Requests to this endpoint require a valid bearer token in JWT format to be provided
in the 'Authorization' header (e.g. 'Authorization: Bearer <bearer-token>').


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param runid Run Id
 @return ApiGetRasRunLogRequest
*/
func (a *ResultArchiveStoreAPIAPIService) GetRasRunLog(ctx context.Context, runid string) ApiGetRasRunLogRequest {
	return ApiGetRasRunLogRequest{
		ApiService: a,
		ctx: ctx,
		runid: runid,
	}
}

// Execute executes the request
//  @return string
func (a *ResultArchiveStoreAPIAPIService) GetRasRunLogExecute(r ApiGetRasRunLogRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResultArchiveStoreAPIAPIService.GetRasRunLog")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ras/runs/{runid}/runlog"
	localVarPath = strings.Replace(localVarPath, "{"+"runid"+"}", url.PathEscape(parameterValueToString(r.runid, "runid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.clientApiVersion != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "ClientApiVersion", r.clientApiVersion, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRasSearchRunsRequest struct {
	ctx context.Context
	ApiService *ResultArchiveStoreAPIAPIService
	sort *string
	clientApiVersion *string
	result *string
	status *string
	bundle *string
	requestor *string
	from *time.Time
	to *time.Time
	testname *string
	page *int32
	size *int32
	runId *string
	runname *string
	includeCursor *string
	cursor *string
}

// Sorts the returned runs based on the sort field. Supports sorting fields &#39;from&#39;, &#39;to&#39;, &#39;result&#39; and &#39;testclass&#39;.  If omitted, runs will be sorted in descending order based on their &#39;queued&#39; time, which is equivalent to specifying &#39;from:desc&#39; (i.e. latest queued run first, oldest last).  When sorting with &#39;to&#39; or &#39;result&#39;, runs that have not yet finished will not be included in responses from this endpoint.  Use &#39;{FIELD-NAME}:asc&#39; to sort in ascending order. Use &#39;{FIELD-NAME}:desc&#39; to sort in descending order. 
func (r ApiGetRasSearchRunsRequest) Sort(sort string) ApiGetRasSearchRunsRequest {
	r.sort = &sort
	return r
}

func (r ApiGetRasSearchRunsRequest) ClientApiVersion(clientApiVersion string) ApiGetRasSearchRunsRequest {
	r.clientApiVersion = &clientApiVersion
	return r
}

// Result Status for the run. Commonly queried values: &#39;EnvFail&#39;,&#39;Passed&#39;,&#39;Failed&#39; Multiple values can be used in the query for example: &#39;EnvFail,Passed,Failed&#39;. Values are case insensitive. For example &#39;PASSED&#39; and &#39;passED&#39; will both be valid. 
func (r ApiGetRasSearchRunsRequest) Result(result string) ApiGetRasSearchRunsRequest {
	r.result = &result
	return r
}

// Test run lifecycle status. Current possibles: &#39;finished&#39;,&#39;building&#39;,&#39;generating&#39;,&#39;running&#39;,&#39;rundone&#39;,&#39;up&#39;,&#39;started&#39;,&#39;provstart&#39;,&#39;ending&#39;. These are not case sensitive. Multiple values can be used in the query for example: &#39;finished,running,started&#39;. Values are case insensitive. For example &#39;FINISHED&#39; and &#39;finiSHed&#39; will both be valid. 
func (r ApiGetRasSearchRunsRequest) Status(status string) ApiGetRasSearchRunsRequest {
	r.status = &status
	return r
}

// The name of the OSGi bundle that the desired test run(s) were loaded with. 
func (r ApiGetRasSearchRunsRequest) Bundle(bundle string) ApiGetRasSearchRunsRequest {
	r.bundle = &bundle
	return r
}

// Name of the test requestor / submitter
func (r ApiGetRasSearchRunsRequest) Requestor(requestor string) ApiGetRasSearchRunsRequest {
	r.requestor = &requestor
	return r
}

// Retrieve runs that started at a time after this date and time.  The only scenario in which from can be omitted is when a runname has been supplied 
func (r ApiGetRasSearchRunsRequest) From(from time.Time) ApiGetRasSearchRunsRequest {
	r.from = &from
	return r
}

// Retrieve runs that ended at a date and time prior to this date and time value. If you specify this parameter, only test runs which have completed will be returned. Tests currently in-flight will not be visible. 
func (r ApiGetRasSearchRunsRequest) To(to time.Time) ApiGetRasSearchRunsRequest {
	r.to = &to
	return r
}

// The full test name (package + short test name)
func (r ApiGetRasSearchRunsRequest) Testname(testname string) ApiGetRasSearchRunsRequest {
	r.testname = &testname
	return r
}

// Deprecated (since 0.37.0) - Use the &#39;cursor&#39; query parameter instead. Causes a specific page in the available results to be returned. The first page is page 1. If omitted, then page 1 is returned. 
func (r ApiGetRasSearchRunsRequest) Page(page int32) ApiGetRasSearchRunsRequest {
	r.page = &page
	return r
}

// The number of test results returned within each page. If omitted, the default value is 100. 
func (r ApiGetRasSearchRunsRequest) Size(size int32) ApiGetRasSearchRunsRequest {
	r.size = &size
	return r
}

// The ID for a specific test run as seen by the RAS. This number is unique across the system, so using this field you can expect one or zero test runs in the first page. 
func (r ApiGetRasSearchRunsRequest) RunId(runId string) ApiGetRasSearchRunsRequest {
	r.runId = &runId
	return r
}

// The name of the test run for which details will be returned. It will normally be unique, but this is not guaranteed, so you may see multiple results for the same runname under some rare circumstances. 
func (r ApiGetRasSearchRunsRequest) Runname(runname string) ApiGetRasSearchRunsRequest {
	r.runname = &runname
	return r
}

// A boolean flag to enable cursor-based pagination and return the next page cursor in the response. If omitted, it will default to false. 
func (r ApiGetRasSearchRunsRequest) IncludeCursor(includeCursor string) ApiGetRasSearchRunsRequest {
	r.includeCursor = &includeCursor
	return r
}

// The cursor representing the page of runs to be retrieved. This is a unique value that is specific to a query and is included in responses, allowing you to navigate through pages of runs. If omitted, the first page of runs for the given query will be returned and the response will display the cursor for the next page of runs. 
func (r ApiGetRasSearchRunsRequest) Cursor(cursor string) ApiGetRasSearchRunsRequest {
	r.cursor = &cursor
	return r
}

func (r ApiGetRasSearchRunsRequest) Execute() (*RunResults, *http.Response, error) {
	return r.ApiService.GetRasSearchRunsExecute(r)
}

/*
GetRasSearchRuns Get Runs from Query

API endpoint to query the Result Archive Store (RAS) for a (possibly sorted)
list of runs based on the given search criteria.

The results returned are paginated, in that the number of desired records per page can be
set, and if there are more test run records to retrieve, requests can be made for
successive pages of results using the same query parameters, but varying the 'page' value.

Note: When querying multiple pages of results, tests may complete, or be started between
successive calls to this endpoint. When the 'to' field is not used, no timeframe
limit is specified in the query, so results retrieved in later pages may contain
test runs which were already retrieved in previous pages of the same query critera.

Invalid query parameters are ignored. For example: a 'cache-buster' parameter.

Requests to this endpoint require a valid bearer token in JWT format to be provided
in the 'Authorization' header (e.g. 'Authorization: Bearer <bearer-token>').


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetRasSearchRunsRequest
*/
func (a *ResultArchiveStoreAPIAPIService) GetRasSearchRuns(ctx context.Context) ApiGetRasSearchRunsRequest {
	return ApiGetRasSearchRunsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RunResults
func (a *ResultArchiveStoreAPIAPIService) GetRasSearchRunsExecute(r ApiGetRasSearchRunsRequest) (*RunResults, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RunResults
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResultArchiveStoreAPIAPIService.GetRasSearchRuns")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ras/runs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sort == nil {
		return localVarReturnValue, nil, reportError("sort is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	if r.result != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "result", r.result, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	if r.bundle != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bundle", r.bundle, "form", "")
	}
	if r.requestor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "requestor", r.requestor, "form", "")
	}
	if r.from != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from", r.from, "form", "")
	}
	if r.to != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "to", r.to, "form", "")
	}
	if r.testname != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "testname", r.testname, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	}
	if r.runId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "runId", r.runId, "form", "")
	}
	if r.runname != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "runname", r.runname, "form", "")
	}
	if r.includeCursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeCursor", r.includeCursor, "form", "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.clientApiVersion != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "ClientApiVersion", r.clientApiVersion, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRasTestclassesRequest struct {
	ctx context.Context
	ApiService *ResultArchiveStoreAPIAPIService
	clientApiVersion *string
	sort *string
}

func (r ApiGetRasTestclassesRequest) ClientApiVersion(clientApiVersion string) ApiGetRasTestclassesRequest {
	r.clientApiVersion = &clientApiVersion
	return r
}

// Provide Sorting
func (r ApiGetRasTestclassesRequest) Sort(sort string) ApiGetRasTestclassesRequest {
	r.sort = &sort
	return r
}

func (r ApiGetRasTestclassesRequest) Execute() (*TestClasses, *http.Response, error) {
	return r.ApiService.GetRasTestclassesExecute(r)
}

/*
GetRasTestclasses Get all the known test classes

Returns a list of the known test classes registered in the ecosystem.

Requests to this endpoint require a valid bearer token in JWT format to be provided
in the 'Authorization' header (e.g. 'Authorization: Bearer <bearer-token>').


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetRasTestclassesRequest
*/
func (a *ResultArchiveStoreAPIAPIService) GetRasTestclasses(ctx context.Context) ApiGetRasTestclassesRequest {
	return ApiGetRasTestclassesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TestClasses
func (a *ResultArchiveStoreAPIAPIService) GetRasTestclassesExecute(r ApiGetRasTestclassesRequest) (*TestClasses, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TestClasses
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResultArchiveStoreAPIAPIService.GetRasTestclasses")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ras/testclasses"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.clientApiVersion != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "ClientApiVersion", r.clientApiVersion, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutRasRunStatusByIdRequest struct {
	ctx context.Context
	ApiService *ResultArchiveStoreAPIAPIService
	runid string
	updateRunStatusRequest *UpdateRunStatusRequest
	clientApiVersion *string
}

func (r ApiPutRasRunStatusByIdRequest) UpdateRunStatusRequest(updateRunStatusRequest UpdateRunStatusRequest) ApiPutRasRunStatusByIdRequest {
	r.updateRunStatusRequest = &updateRunStatusRequest
	return r
}

func (r ApiPutRasRunStatusByIdRequest) ClientApiVersion(clientApiVersion string) ApiPutRasRunStatusByIdRequest {
	r.clientApiVersion = &clientApiVersion
	return r
}

func (r ApiPutRasRunStatusByIdRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.PutRasRunStatusByIdExecute(r)
}

/*
PutRasRunStatusById Update the status of a test run

Updates the status of a test run in order to either reset or cancel it.

Requests to this endpoint require a valid bearer token in JWT format to be provided
in the 'Authorization' header (e.g. 'Authorization: Bearer <bearer-token>').


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param runid Run Id which starts \"cdb-\". This is NOT the short run-name (e.g. C1234)
 @return ApiPutRasRunStatusByIdRequest
*/
func (a *ResultArchiveStoreAPIAPIService) PutRasRunStatusById(ctx context.Context, runid string) ApiPutRasRunStatusByIdRequest {
	return ApiPutRasRunStatusByIdRequest{
		ApiService: a,
		ctx: ctx,
		runid: runid,
	}
}

// Execute executes the request
//  @return string
func (a *ResultArchiveStoreAPIAPIService) PutRasRunStatusByIdExecute(r ApiPutRasRunStatusByIdRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResultArchiveStoreAPIAPIService.PutRasRunStatusById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ras/runs/{runid}"
	localVarPath = strings.Replace(localVarPath, "{"+"runid"+"}", url.PathEscape(parameterValueToString(r.runid, "runid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateRunStatusRequest == nil {
		return localVarReturnValue, nil, reportError("updateRunStatusRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.clientApiVersion != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "ClientApiVersion", r.clientApiVersion, "simple", "")
	}
	// body params
	localVarPostBody = r.updateRunStatusRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
