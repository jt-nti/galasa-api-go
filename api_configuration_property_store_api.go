/*
Galasa Ecosystem API

The Galasa Ecosystem REST API allows you to interact with a Galasa Ecosystem.

API version: 0.37.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package galasaapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// ConfigurationPropertyStoreAPIAPIService ConfigurationPropertyStoreAPIAPI service
type ConfigurationPropertyStoreAPIAPIService service

type ApiCreateCpsPropertyRequest struct {
	ctx context.Context
	ApiService *ConfigurationPropertyStoreAPIAPIService
	namespace string
	galasaProperty *GalasaProperty
	clientApiVersion *string
}

// The value of the property being created.
func (r ApiCreateCpsPropertyRequest) GalasaProperty(galasaProperty GalasaProperty) ApiCreateCpsPropertyRequest {
	r.galasaProperty = &galasaProperty
	return r
}

func (r ApiCreateCpsPropertyRequest) ClientApiVersion(clientApiVersion string) ApiCreateCpsPropertyRequest {
	r.clientApiVersion = &clientApiVersion
	return r
}

func (r ApiCreateCpsPropertyRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.CreateCpsPropertyExecute(r)
}

/*
CreateCpsProperty Create a new CPS property

Create a new property with the supplied value in the given Namespace within the Configuration Property Store.

Requests to this endpoint require a valid bearer token in JWT format to be provided
in the 'Authorization' header (e.g. 'Authorization: Bearer <bearer-token>').


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace Property Namespace. First character of the namespace must be in the 'a'-'z' range, and following characters can be 'a'-'z' or '0'-'9' 
 @return ApiCreateCpsPropertyRequest
*/
func (a *ConfigurationPropertyStoreAPIAPIService) CreateCpsProperty(ctx context.Context, namespace string) ApiCreateCpsPropertyRequest {
	return ApiCreateCpsPropertyRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return string
func (a *ConfigurationPropertyStoreAPIAPIService) CreateCpsPropertyExecute(r ApiCreateCpsPropertyRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationPropertyStoreAPIAPIService.CreateCpsProperty")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cps/{namespace}/properties"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterValueToString(r.namespace, "namespace")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.galasaProperty == nil {
		return localVarReturnValue, nil, reportError("galasaProperty is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.clientApiVersion != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "ClientApiVersion", r.clientApiVersion, "simple", "")
	}
	// body params
	localVarPostBody = r.galasaProperty
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 411 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCpsPropertyRequest struct {
	ctx context.Context
	ApiService *ConfigurationPropertyStoreAPIAPIService
	namespace string
	propertyName string
	clientApiVersion *string
}

func (r ApiDeleteCpsPropertyRequest) ClientApiVersion(clientApiVersion string) ApiDeleteCpsPropertyRequest {
	r.clientApiVersion = &clientApiVersion
	return r
}

func (r ApiDeleteCpsPropertyRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.DeleteCpsPropertyExecute(r)
}

/*
DeleteCpsProperty Delete existing CPS property

Delete an existing property in a given namepace in the Configuration Properties Store.

Requests to this endpoint require a valid bearer token in JWT format to be provided
in the 'Authorization' header (e.g. 'Authorization: Bearer <bearer-token>').


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace Property Namespace. First character of the namespace must be in the 'a'-'z' range, and following characters can be 'a'-'z' or '0'-'9' 
 @param propertyName Property Name. The first character of the namespace must be in the 'a'-'z' or 'A'-'Z' ranges, and following characters can be 'a'-'z', 'A'-'Z', '0'-'9', '.' (period), '-' (dash) or '_' (underscore) 
 @return ApiDeleteCpsPropertyRequest
*/
func (a *ConfigurationPropertyStoreAPIAPIService) DeleteCpsProperty(ctx context.Context, namespace string, propertyName string) ApiDeleteCpsPropertyRequest {
	return ApiDeleteCpsPropertyRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
		propertyName: propertyName,
	}
}

// Execute executes the request
//  @return string
func (a *ConfigurationPropertyStoreAPIAPIService) DeleteCpsPropertyExecute(r ApiDeleteCpsPropertyRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationPropertyStoreAPIAPIService.DeleteCpsProperty")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cps/{namespace}/properties/{propertyName}"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterValueToString(r.namespace, "namespace")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"propertyName"+"}", url.PathEscape(parameterValueToString(r.propertyName, "propertyName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.clientApiVersion != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "ClientApiVersion", r.clientApiVersion, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAllCpsNamespacesRequest struct {
	ctx context.Context
	ApiService *ConfigurationPropertyStoreAPIAPIService
	clientApiVersion *string
}

func (r ApiGetAllCpsNamespacesRequest) ClientApiVersion(clientApiVersion string) ApiGetAllCpsNamespacesRequest {
	r.clientApiVersion = &clientApiVersion
	return r
}

func (r ApiGetAllCpsNamespacesRequest) Execute() ([]Namespace, *http.Response, error) {
	return r.ApiService.GetAllCpsNamespacesExecute(r)
}

/*
GetAllCpsNamespaces Get all known CPS namespaces

Returns a list of all namespaces in the Configuration Property Store.

Requests to this endpoint require a valid bearer token in JWT format to be provided
in the 'Authorization' header (e.g. 'Authorization: Bearer <bearer-token>').


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAllCpsNamespacesRequest
*/
func (a *ConfigurationPropertyStoreAPIAPIService) GetAllCpsNamespaces(ctx context.Context) ApiGetAllCpsNamespacesRequest {
	return ApiGetAllCpsNamespacesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Namespace
func (a *ConfigurationPropertyStoreAPIAPIService) GetAllCpsNamespacesExecute(r ApiGetAllCpsNamespacesRequest) ([]Namespace, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Namespace
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationPropertyStoreAPIAPIService.GetAllCpsNamespaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cps"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.clientApiVersion != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "ClientApiVersion", r.clientApiVersion, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCpsNamespaceCascadePropertyRequest struct {
	ctx context.Context
	ApiService *ConfigurationPropertyStoreAPIAPIService
	namespace string
	prefix string
	suffix string
	clientApiVersion *string
	infixes *[]string
}

func (r ApiGetCpsNamespaceCascadePropertyRequest) ClientApiVersion(clientApiVersion string) ApiGetCpsNamespaceCascadePropertyRequest {
	r.clientApiVersion = &clientApiVersion
	return r
}

// Property infixes. The first character of the namespace must be in the &#39;a&#39;-&#39;z&#39; or &#39;A&#39;-&#39;Z&#39; ranges, and following characters can be &#39;a&#39;-&#39;z&#39;, &#39;A&#39;-&#39;Z&#39;, &#39;0&#39;-&#39;9&#39;, &#39;.&#39; (period), &#39;-&#39; (dash) or &#39;_&#39; (underscore) 
func (r ApiGetCpsNamespaceCascadePropertyRequest) Infixes(infixes []string) ApiGetCpsNamespaceCascadePropertyRequest {
	r.infixes = &infixes
	return r
}

func (r ApiGetCpsNamespaceCascadePropertyRequest) Execute() (*CpsProperty, *http.Response, error) {
	return r.ApiService.GetCpsNamespaceCascadePropertyExecute(r)
}

/*
GetCpsNamespaceCascadeProperty Get cascade CPS property

Searches for a property using namespace, prefix suffix and infixes.
Deprecated in v0.31.0.
Use the /cps/{namespace}/properties call instead, using the prefix, suffix and infix query parameters, instead of this call.
This call will be removed in a future version of this REST API.

Requests to this endpoint require a valid bearer token in JWT format to be provided
in the 'Authorization' header (e.g. 'Authorization: Bearer <bearer-token>').


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace Property Namespace. The first character of the namespace must be in the 'a'-'z' or 'A'-'Z' ranges, and following characters can be 'a'-'z' or 'A'-'Z' or '0'-'9' 
 @param prefix Property Prefix. The first character of the namespace must be in the 'a'-'z' or 'A'-'Z' ranges,   and following characters can be 'a'-'z', 'A'-'Z', '0'-'9', '.' (period), '-' (dash) or '_' (underscore) 
 @param suffix Property suffix. The first character of the namespace must be in the 'a'-'z' or 'A'-'Z' ranges, and following characters can be 'a'-'z', 'A'-'Z', '0'-'9', '.' (period), '-' (dash) or '_' (underscore) 
 @return ApiGetCpsNamespaceCascadePropertyRequest

Deprecated
*/
func (a *ConfigurationPropertyStoreAPIAPIService) GetCpsNamespaceCascadeProperty(ctx context.Context, namespace string, prefix string, suffix string) ApiGetCpsNamespaceCascadePropertyRequest {
	return ApiGetCpsNamespaceCascadePropertyRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
		prefix: prefix,
		suffix: suffix,
	}
}

// Execute executes the request
//  @return CpsProperty
// Deprecated
func (a *ConfigurationPropertyStoreAPIAPIService) GetCpsNamespaceCascadePropertyExecute(r ApiGetCpsNamespaceCascadePropertyRequest) (*CpsProperty, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CpsProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationPropertyStoreAPIAPIService.GetCpsNamespaceCascadeProperty")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cps/namespace/{namespace}/prefix/{prefix}/suffix/{suffix}"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterValueToString(r.namespace, "namespace")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"prefix"+"}", url.PathEscape(parameterValueToString(r.prefix, "prefix")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"suffix"+"}", url.PathEscape(parameterValueToString(r.suffix, "suffix")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.infixes != nil {
		t := *r.infixes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "infixes", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "infixes", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.clientApiVersion != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "ClientApiVersion", r.clientApiVersion, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCpsNamespacePropertiesRequest struct {
	ctx context.Context
	ApiService *ConfigurationPropertyStoreAPIAPIService
	namespace string
	clientApiVersion *string
}

func (r ApiGetCpsNamespacePropertiesRequest) ClientApiVersion(clientApiVersion string) ApiGetCpsNamespacePropertiesRequest {
	r.clientApiVersion = &clientApiVersion
	return r
}

func (r ApiGetCpsNamespacePropertiesRequest) Execute() ([]GalasaProperty, *http.Response, error) {
	return r.ApiService.GetCpsNamespacePropertiesExecute(r)
}

/*
GetCpsNamespaceProperties Get all properties for a namepace

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace Property Namespace. First character of the namespace must be in the 'a'-'z' range, and following characters can be 'a'-'z' or '0'-'9' 
 @return ApiGetCpsNamespacePropertiesRequest

Deprecated
*/
func (a *ConfigurationPropertyStoreAPIAPIService) GetCpsNamespaceProperties(ctx context.Context, namespace string) ApiGetCpsNamespacePropertiesRequest {
	return ApiGetCpsNamespacePropertiesRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return []GalasaProperty
// Deprecated
func (a *ConfigurationPropertyStoreAPIAPIService) GetCpsNamespacePropertiesExecute(r ApiGetCpsNamespacePropertiesRequest) ([]GalasaProperty, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GalasaProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationPropertyStoreAPIAPIService.GetCpsNamespaceProperties")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cps/namespace/{namespace}"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterValueToString(r.namespace, "namespace")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.clientApiVersion != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "ClientApiVersion", r.clientApiVersion, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCpsNamespacesRequest struct {
	ctx context.Context
	ApiService *ConfigurationPropertyStoreAPIAPIService
	clientApiVersion *string
}

func (r ApiGetCpsNamespacesRequest) ClientApiVersion(clientApiVersion string) ApiGetCpsNamespacesRequest {
	r.clientApiVersion = &clientApiVersion
	return r
}

func (r ApiGetCpsNamespacesRequest) Execute() ([]string, *http.Response, error) {
	return r.ApiService.GetCpsNamespacesExecute(r)
}

/*
GetCpsNamespaces Get CPS Namespaces

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCpsNamespacesRequest

Deprecated
*/
func (a *ConfigurationPropertyStoreAPIAPIService) GetCpsNamespaces(ctx context.Context) ApiGetCpsNamespacesRequest {
	return ApiGetCpsNamespacesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []string
// Deprecated
func (a *ConfigurationPropertyStoreAPIAPIService) GetCpsNamespacesExecute(r ApiGetCpsNamespacesRequest) ([]string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationPropertyStoreAPIAPIService.GetCpsNamespaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cps/namespace"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.clientApiVersion != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "ClientApiVersion", r.clientApiVersion, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCpsPropertyRequest struct {
	ctx context.Context
	ApiService *ConfigurationPropertyStoreAPIAPIService
	namespace string
	propertyName string
	clientApiVersion *string
}

func (r ApiGetCpsPropertyRequest) ClientApiVersion(clientApiVersion string) ApiGetCpsPropertyRequest {
	r.clientApiVersion = &clientApiVersion
	return r
}

func (r ApiGetCpsPropertyRequest) Execute() ([]GalasaProperty, *http.Response, error) {
	return r.ApiService.GetCpsPropertyExecute(r)
}

/*
GetCpsProperty Get single CPS property

Returns a property, value pair that matches the full propertyName in the given namespace within the Configuration Property Store.

Requests to this endpoint require a valid bearer token in JWT format to be provided
in the 'Authorization' header (e.g. 'Authorization: Bearer <bearer-token>').


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace Property Namespace. First character of the namespace must be in the 'a'-'z' range, and following characters can be 'a'-'z' or '0'-'9' 
 @param propertyName Property Name. The first character of the namespace must be in the 'a'-'z' or 'A'-'Z' ranges, and following characters can be 'a'-'z', 'A'-'Z', '0'-'9', '.' (period), '-' (dash) or '_' (underscore) 
 @return ApiGetCpsPropertyRequest
*/
func (a *ConfigurationPropertyStoreAPIAPIService) GetCpsProperty(ctx context.Context, namespace string, propertyName string) ApiGetCpsPropertyRequest {
	return ApiGetCpsPropertyRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
		propertyName: propertyName,
	}
}

// Execute executes the request
//  @return []GalasaProperty
func (a *ConfigurationPropertyStoreAPIAPIService) GetCpsPropertyExecute(r ApiGetCpsPropertyRequest) ([]GalasaProperty, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GalasaProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationPropertyStoreAPIAPIService.GetCpsProperty")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cps/{namespace}/properties/{propertyName}"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterValueToString(r.namespace, "namespace")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"propertyName"+"}", url.PathEscape(parameterValueToString(r.propertyName, "propertyName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.clientApiVersion != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "ClientApiVersion", r.clientApiVersion, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutCpsNamespacePropertyRequest struct {
	ctx context.Context
	ApiService *ConfigurationPropertyStoreAPIAPIService
	namespace string
	property string
	cpsProperty *CpsProperty
	clientApiVersion *string
}

func (r ApiPutCpsNamespacePropertyRequest) CpsProperty(cpsProperty CpsProperty) ApiPutCpsNamespacePropertyRequest {
	r.cpsProperty = &cpsProperty
	return r
}

func (r ApiPutCpsNamespacePropertyRequest) ClientApiVersion(clientApiVersion string) ApiPutCpsNamespacePropertyRequest {
	r.clientApiVersion = &clientApiVersion
	return r
}

func (r ApiPutCpsNamespacePropertyRequest) Execute() (*CpsProperty, *http.Response, error) {
	return r.ApiService.PutCpsNamespacePropertyExecute(r)
}

/*
PutCpsNamespaceProperty Put new CPS Property

Searches multiple places in the property store for the first property matching the namespace,
prefix and suffix, and as many of the leading infix strings as possible.
This results in a value which is the most specific, given a sparsely populated hierarchical
structure of property names.
Over-rides of values (if present) are returned in preference to the normal stored value
of a property.

Requests to this endpoint require a valid bearer token in JWT format to be provided
in the 'Authorization' header (e.g. 'Authorization: Bearer <bearer-token>').


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace Property Namespace. First character of the namespace must be in the 'a'-'z' range, and following characters can be 'a'-'z' or '0'-'9' 
 @param property Property Name. The first character of the namespace must be in the 'a'-'z' or 'A'-'Z' ranges, and following characters can be 'a'-'z', 'A'-'Z', '0'-'9', '.' (period), '-' (dash) or '_' (underscore) 
 @return ApiPutCpsNamespacePropertyRequest

Deprecated
*/
func (a *ConfigurationPropertyStoreAPIAPIService) PutCpsNamespaceProperty(ctx context.Context, namespace string, property string) ApiPutCpsNamespacePropertyRequest {
	return ApiPutCpsNamespacePropertyRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
		property: property,
	}
}

// Execute executes the request
//  @return CpsProperty
// Deprecated
func (a *ConfigurationPropertyStoreAPIAPIService) PutCpsNamespacePropertyExecute(r ApiPutCpsNamespacePropertyRequest) (*CpsProperty, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CpsProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationPropertyStoreAPIAPIService.PutCpsNamespaceProperty")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cps/namespace/{namespace}/property/{property}"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterValueToString(r.namespace, "namespace")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"property"+"}", url.PathEscape(parameterValueToString(r.property, "property")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.cpsProperty == nil {
		return localVarReturnValue, nil, reportError("cpsProperty is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.clientApiVersion != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "ClientApiVersion", r.clientApiVersion, "simple", "")
	}
	// body params
	localVarPostBody = r.cpsProperty
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQueryCpsNamespacePropertiesRequest struct {
	ctx context.Context
	ApiService *ConfigurationPropertyStoreAPIAPIService
	namespace string
	clientApiVersion *string
	prefix *string
	suffix *string
	infix *string
}

func (r ApiQueryCpsNamespacePropertiesRequest) ClientApiVersion(clientApiVersion string) ApiQueryCpsNamespacePropertiesRequest {
	r.clientApiVersion = &clientApiVersion
	return r
}

// Property Prefix. The first character must be in the &#39;a&#39;-&#39;z&#39; or &#39;A&#39;-&#39;Z&#39; ranges,   and following characters can be &#39;a&#39;-&#39;z&#39;, &#39;A&#39;-&#39;Z&#39;, &#39;0&#39;-&#39;9&#39;, &#39;.&#39; (period), &#39;-&#39; (dash) or &#39;_&#39; (underscore) 
func (r ApiQueryCpsNamespacePropertiesRequest) Prefix(prefix string) ApiQueryCpsNamespacePropertiesRequest {
	r.prefix = &prefix
	return r
}

// Property suffix. The first character must be in the &#39;a&#39;-&#39;z&#39; or &#39;A&#39;-&#39;Z&#39; ranges, and following characters can be &#39;a&#39;-&#39;z&#39;, &#39;A&#39;-&#39;Z&#39;, &#39;0&#39;-&#39;9&#39;, &#39;.&#39; (period), &#39;-&#39; (dash) or &#39;_&#39; (underscore) 
func (r ApiQueryCpsNamespacePropertiesRequest) Suffix(suffix string) ApiQueryCpsNamespacePropertiesRequest {
	r.suffix = &suffix
	return r
}

// Comma-separated list of Property infixes. The first character of each infix must be in the &#39;a&#39;-&#39;z&#39; or &#39;A&#39;-&#39;Z&#39; ranges, and following characters can be &#39;a&#39;-&#39;z&#39;, &#39;A&#39;-&#39;Z&#39;, &#39;0&#39;-&#39;9&#39;, &#39;.&#39; (period), &#39;-&#39; (dash) or &#39;_&#39; (underscore) 
func (r ApiQueryCpsNamespacePropertiesRequest) Infix(infix string) ApiQueryCpsNamespacePropertiesRequest {
	r.infix = &infix
	return r
}

func (r ApiQueryCpsNamespacePropertiesRequest) Execute() ([]GalasaProperty, *http.Response, error) {
	return r.ApiService.QueryCpsNamespacePropertiesExecute(r)
}

/*
QueryCpsNamespaceProperties Get all CPS namespace properties

Returns a list of all properties in the given namespace within the Configuration Property Store.

Requests to this endpoint require a valid bearer token in JWT format to be provided
in the 'Authorization' header (e.g. 'Authorization: Bearer <bearer-token>').


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace Property Namespace. First character of the namespace must be in the 'a'-'z' range, and following characters can be 'a'-'z' or '0'-'9' 
 @return ApiQueryCpsNamespacePropertiesRequest
*/
func (a *ConfigurationPropertyStoreAPIAPIService) QueryCpsNamespaceProperties(ctx context.Context, namespace string) ApiQueryCpsNamespacePropertiesRequest {
	return ApiQueryCpsNamespacePropertiesRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return []GalasaProperty
func (a *ConfigurationPropertyStoreAPIAPIService) QueryCpsNamespacePropertiesExecute(r ApiQueryCpsNamespacePropertiesRequest) ([]GalasaProperty, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GalasaProperty
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationPropertyStoreAPIAPIService.QueryCpsNamespaceProperties")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cps/{namespace}/properties"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterValueToString(r.namespace, "namespace")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.prefix != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prefix", r.prefix, "form", "")
	}
	if r.suffix != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "suffix", r.suffix, "form", "")
	}
	if r.infix != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "infix", r.infix, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.clientApiVersion != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "ClientApiVersion", r.clientApiVersion, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateCpsPropertyRequest struct {
	ctx context.Context
	ApiService *ConfigurationPropertyStoreAPIAPIService
	namespace string
	propertyName string
	galasaProperty *GalasaProperty
	clientApiVersion *string
}

// The value of the property being created.
func (r ApiUpdateCpsPropertyRequest) GalasaProperty(galasaProperty GalasaProperty) ApiUpdateCpsPropertyRequest {
	r.galasaProperty = &galasaProperty
	return r
}

func (r ApiUpdateCpsPropertyRequest) ClientApiVersion(clientApiVersion string) ApiUpdateCpsPropertyRequest {
	r.clientApiVersion = &clientApiVersion
	return r
}

func (r ApiUpdateCpsPropertyRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.UpdateCpsPropertyExecute(r)
}

/*
UpdateCpsProperty Update existing CPS property

Update an existing property in a given namepace in the Configuration Properties Store.

Requests to this endpoint require a valid bearer token in JWT format to be provided
in the 'Authorization' header (e.g. 'Authorization: Bearer <bearer-token>').


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace Property Namespace. First character of the namespace must be in the 'a'-'z' range, and following characters can be 'a'-'z' or '0'-'9' 
 @param propertyName Property Name. The first character of the namespace must be in the 'a'-'z' or 'A'-'Z' ranges, and following characters can be 'a'-'z', 'A'-'Z', '0'-'9', '.' (period), '-' (dash) or '_' (underscore) 
 @return ApiUpdateCpsPropertyRequest
*/
func (a *ConfigurationPropertyStoreAPIAPIService) UpdateCpsProperty(ctx context.Context, namespace string, propertyName string) ApiUpdateCpsPropertyRequest {
	return ApiUpdateCpsPropertyRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
		propertyName: propertyName,
	}
}

// Execute executes the request
//  @return string
func (a *ConfigurationPropertyStoreAPIAPIService) UpdateCpsPropertyExecute(r ApiUpdateCpsPropertyRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationPropertyStoreAPIAPIService.UpdateCpsProperty")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cps/{namespace}/properties/{propertyName}"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterValueToString(r.namespace, "namespace")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"propertyName"+"}", url.PathEscape(parameterValueToString(r.propertyName, "propertyName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.galasaProperty == nil {
		return localVarReturnValue, nil, reportError("galasaProperty is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.clientApiVersion != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "ClientApiVersion", r.clientApiVersion, "simple", "")
	}
	// body params
	localVarPostBody = r.galasaProperty
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 411 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
